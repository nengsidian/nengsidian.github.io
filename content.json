{"meta":{"title":"李恒的博客","subtitle":"记录知识，带来成长","description":"记录python、java等语言的编程知识","author":"liheng","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2020-05-16T01:00:17.000Z","updated":"2020-05-16T01:01:07.198Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-16T01:02:23.000Z","updated":"2020-05-16T01:02:46.515Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pycharm快捷键大全","slug":"others/pycharm快捷键大全","date":"2020-05-16T01:05:57.000Z","updated":"2020-05-16T01:05:56.253Z","comments":true,"path":"2020/05/16/others/pycharm快捷键大全/","link":"","permalink":"http://yoursite.com/2020/05/16/others/pycharm%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/","excerpt":"","text":"#pycharm快捷键大全 1、编辑（Editing）Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 F1 Web帮助文档主页 Shift + F1 选中对象的Web帮助文档 Ctrl + 悬浮/单击鼠标左键 简介/进入代码定义 Ctrl + Z 撤销上次操作 Ctrl + Shift + Z 重做,恢复上次的撤销 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释/取消注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开/折叠代码块（当前位置：函数、注释等） Ctrl + Shift + Numpad+/- 展开/折叠所有代码块 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace)F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + R 全局替换 Ctrl + Shift + F 全局查找（可以在整个项目中查找某个字符串什么的，如查找某个函数名） 连续敲击两次Shift键 查找函数 3、运行(Running)Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging)F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation)Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡（代码文件） Alt + Up/Down跳转到上一个、下一个方法 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 在当前文件弹出最近使用的文件列表 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域（差不多就是返回上次编辑的位置） Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I 查看快速定义 Ctrl + Shift + B 跳转到类型声明 Ctrl + U 跳转到父方法、父类 Alt + Up/Down 跳转到上一个、下一个方法 Ctrl + ]/[ 跳转到代码块结束、开始 Ctrl + F12 弹出文件结构 Ctrl + H 类型层次结构 Ctrl + Shift + H 方法层次结构 Ctrl + Alt + H 调用层次结构 F2 / Shift + F2 下一条、前一条高亮的错误 F4 / Ctrl + Enter 编辑资源、查看资源 Alt + Home显示导航条F11 书签开关 Ctrl + Shift + F11 书签助记开关 Ctrl + #[0-9] 跳转到标识的书签 Shift + F11 显示书签 6、搜索相关(Usage Search)Alt + F7/Ctrl + F7 文件中查询用法 Ctrl + Shift + F7 文件中用法高亮显示 Ctrl + Alt + F7 显示用法 7、重构(Refactoring)Alt + Delete 安全删除 Shift + F6 重命名文件 Ctrl + F6 更改签名 Ctrl + Alt + N 内联 Ctrl + Alt + M 提取方法 Ctrl + Alt + V 提取属性 Ctrl + Alt + F 提取字段 Ctrl + Alt + C 提取常量 Ctrl + Alt + P 提取参数 8、控制VCS/Local HistoryCtrl + K 提交项目 Ctrl + T 更新项目 Alt + Shift + C 查看最近的变化 Alt + BackQuote(‘) VCS快速弹出 9、模版(Live Templates)Ctrl + Alt + J 当前行使用模版 Ctrl + J 插入模版 10、基本(General)Alt + #[0-9] 打开相应的工具窗口 Ctrl + Alt + Y 同步 Ctrl + Shift + F12 最大化编辑开关 Alt + Shift + F 添加到最喜欢 Alt + Shift + I 根据配置检查当前文件 Ctrl + BackQuote(‘) 快速切换当前计划 Ctrl + Alt + S 打开设置页 Ctrl + Shift + A 查找编辑器里所有的动作 Ctrl + Tab 在窗口间进行切换","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"pycharm","slug":"pycharm","permalink":"http://yoursite.com/tags/pycharm/"},{"name":"快捷键","slug":"快捷键","permalink":"http://yoursite.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"numpy和pandas","slug":"python/numpy和pandas","date":"2020-05-16T01:05:57.000Z","updated":"2020-05-16T02:06:27.323Z","comments":true,"path":"2020/05/16/python/numpy和pandas/","link":"","permalink":"http://yoursite.com/2020/05/16/python/numpy%E5%92%8Cpandas/","excerpt":"","text":"numpy创建数组12345678a = np.array([1,2,3,4,5])np.arange(12).reshape(3, 4)# 查看数组的类型type(a)# 查看数据的类型a.dtype 指定创建数组的数据类型1234a = np.array([1,0,1,0], dtype=np.bool) # 或者使用dtype='?'# 修改数组的数据类型a.astype(\"i1\") # 或者使用a.astype(np.int8) 修改浮点型的小数位数1np.round(b, 2) # b是浮点型数组 数组的形状123456789101112# 查看数组的形状,得到的结果是一个元组a.shape# 获取数组的行数a.shape[0]# 获取数组的列数a.shape[1]# 修改数组的形状b = a.reshape(2, 6)# 把数组转化为一维数组a.flatten() 数组和数组的计算123# 广播机制a + 1a * 3 如果两个数组的后缘维度（即从末尾开始算起的维度）的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的。广播会在缺失和（或）长度为1的维度上进行。 可以把维度指的是shape所对应的数字。 也就是说两个数组shape得到的元组的后2位要相同，或者后2位中一个相同，另外一个数字有一个数组为1 numpy读取数据123np.loadtxt(fname,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False)# 例如：np.loadtxt(US_video_data_numbers_path, delimiter=\",\", dtype=int,unpack=1) 参数 解释 frame 文件、字符串或产生器，可以是.gz或bz2压缩文件 dtype 数据类型，可选，csv的字符串以什么数据类型读入数组中，默认np.float delimiter 分割字符串，默认是任何空格，改为逗号 skiprows 跳过前X行，一般跳过第一行表头 usecols 读取指定的列，索引，元组类型 unpack 如果True，读入属性将分别写入不同数组变量，False读入数据只写入一个数组变量，默认False。相当于转置的效果 numpy中的转置转置是一种变换，对于numpy中的数组来说，就是在对角线方向交换数据，目的也是为了更方便的去处理数据。 1234# 转置的3种方法t.transpose()t.swapaxes(1,0)t.T numpy的索引和切片123456789a[1] # 取第2行a[1:3] # 取第2到第3行a[:, 2] # 取第3列a[:, 2:4] # 取第3到第4列a[[1,3], :] # 分别取第2行和第3行a[:[2,4]] # 分别取第3列和第4列a[[1:3],[2,4]] # 取第2行第3行和第3列第4列的交集a[:,2:8:2] # 取第3列到第8列，步长为2a[:,2:4] = 0 # 把第3列到第4列的值设置为0 numpy中布尔索引12345678910111213141516t = np.arange(24).reshape(4,6)print(t &lt; 10)&gt;&gt;&gt;array([[ True, True, True, True, True, True], [ True, True, True, True, False, False], [False, False, False, False, False, False], [False, False, False, False, False, False]])# 以上是t&lt;10的输出结果t[t&lt;10]=0print(t)&gt;&gt;&gt;[[ 0 0 0 0 0 0] [ 0 0 0 0 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] numpy中的三元运算符把t中小于10的数字替换为0，把大于10的替换为10 1234567t = np.where(t&lt;10,0,10)print(t)&gt;&gt;&gt;[[ 0 0 0 0 0 0] [ 0 0 0 0 10 10] [10 10 10 10 10 10] [10 10 10 10 10 10]] numpy中的clip（裁剪）把t中小于10的数字替换为10，大于20的数字替换为20，其他数字不变 1234567t = t.clip(10, 20)print(t)&gt;&gt;&gt;[[10 10 10 10 10 10] [10 10 10 10 10 11] [12 13 14 15 16 17] [18 19 20 20 20 20]] numpy中的nan和infnan(NAN,Nan):not a number表示不是一个数字 什么时候会出现numpy中的nan： 当我们读取本地的文件为float的时候，如果有缺失，就会出现nan 当做了一个不合适的计算的时候（比如无穷大（inf）减去无穷大） inf(-inf,inf):infinity，inf表示正无穷，-inf表示负无穷 #####什么时候会出现inf(-inf,inf): 比如一个数字除以0，（python中直接回报错，numpy中是一个inf或者-inf） #####inf和nan的type类型都是float #####nan中的注意点： 两个nan是不相等的，即np.nan != np.nan 可以利用以上的特性，判断数组中nan的个数 np.count_nonzero(t != t) 如果判断一个数字是否为nan呢？通过np.isnan(a)来判断，返回bool类型，比较把nan替换为0 t[np.isnan(t)] = 0 nan和任何值计算都为nan numpy中常用统计函数 求和：t.sum(axis=None) 均值：t.mean(a,axis=None) 受离群点的影响较大 中值：np.median(t,axis=None) 最大值：t.max(axis=None) 最小值：t.min(axis=None) 极值：np.ptp(t,axis=None) 即最大值和最小值只差 标准差： t.std(axis=None) 默认返回多维数组的全部的统计结果，如果指定axis则返回一个当前轴上的结果 标准差：是一组数据平均值分散程度的一种度量。一个较大的标准差，代表大部分数值和其平均值之间差异较大；一个较小的标准差，代表这些数值较接近平均值反映出数据的波动稳定情况，越大表示波动越大，越不稳定。 ndarry缺失值填充均值1234567891011121314151617t = np.array([[ 0., 1., 2., 3., 4., 5.], [ 6., 7., np.nan, 9., 10., 11.], [ 12., 13., 14., np.nan, 16., 17.], [ 18., 19., 20., 21., 22., 23.]])def fill_nan_by_column_mean(t): for i in range(t.shape[1]): nan_num = np.count_nonzero(t[:, i][t[:, i] != t[:, i]]) # 计算非nan的个数 if nan_num &gt; 0: # 存在的nan值 now_col = t[:, i] now_col_not_nan = now_col[np.isnan(now_col) == False].sum() # 求和 now_col_mean = now_col_not_nan / (t.shape[0] - nan_num) # 和/个数 now_col[np.isnan(now_col)] = now_col_mean # 赋值给now_col t[:, i] = now_col # 赋值给t，即更新t的当前列 fill_nan_by_column_mean(t)print(t) 数组的拼接12np.vstack((t1,t2)) # 竖直拼接np.hstack((t1,t2)) # 水平拼接 数组的行列交换12t[[1,2],:] = t[[2,1],:] # 行交换t[:,[0,2]] = t[:,[2,0]] # 列交换 numpy更多好用的方法 获取最大值最小值的位置 np.argmax(t,axis=0) np.argmin(t,axis=1) 创建一个全0的数组：np.zeros((3,4)) 创建一个全1的数组：np.ones((3,4)) 创建一个对角线为1的正方形数组（方阵）：np,eye(3) 生成随机数 numpy的注意点copy和view a=b完全不复制，a和b相互影响 a=b[:]，视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的。 a=b.copy()，复制，a和b互不影响。 pandasnumpy能够帮助我们处理数值，但是pandas除了处理数值之外（基于numpy），还能够帮助我们处理其他类型的数据 pandas之Series创建1234567891011121314151617181920212223242526272829303132333435363738# 方法一import stringt = pd.Series(np.arange(10), index=list(string.ascii_uppercase[:10]))# 方法二a = &#123;string.ascii_uppercase[i]:i for i in range(10)&#125;pd.Series(a)&gt;&gt;&gt;A 0B 1C 2D 3E 4F 5G 6H 7I 8J 9dtype: int64 # 重新指定索引pd.Series(a, index=list(string.ascii_uppercase[5:15]))&gt;&gt;&gt;F 5.0G 6.0H 7.0I 8.0J 9.0K NaNL NaNM NaNN NaNO NaNdtype: float64# 重新给其指定其他的索引之后，如果能够对应上，就取其值，如果不能，就为Nan# 为什么类型为float呢？numpy中nan为float，pandas会自动根据数据类更改series的dtype类型pandas修改dtype和numpy的方法一样 pandas之Series切片和索引切片：直接传入start end或者步长即可 索引：一个的时候直接传入序号或者index，多个的时候传入序号或者index的列表 12345678t = pd.Series(np.arange(10), index=list(\"ABCDEFGHIJ\")) t[2:10:2] # 切片 步长为2t[1] # 取索引t[[2,3,6]] # 取索引，索引分别为2，3，6t[t&gt;4] # 值大于4的所有数据t[\"F\"] # 索引为F的数据t[[\"A\", \"F\", \"g\"]] # 索引为A，F，g的数据，因为索引g没有，所以取出的值为NaN pandas之Series的索引和值Series对象本质上由两个数组构成，一个数组构成对象的键（index, 索引），一个数组构成对象的值（values），键-&gt;值 123456789101112131415t.index&gt;&gt;&gt;Index(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'], dtype='object')t.values&gt;&gt;&gt;array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])type(t.index)&gt;&gt;&gt;pandas.core.indexes.base.Indextype(t.values)&gt;&gt;&gt;numpy.ndarray ndarray的很多方法都可以运用于series类型，比如argmax，clip series具有where方法，但是结果和ndarray不同 Series的tolist()方法和unique()方法123456789df = pd.Series([1,2,1,3,2,1])df.tolist()&gt;&gt;&gt;[1, 2, 1, 3, 2, 1]df = pd.Series([1,2,1,3,2,1])df.unique()&gt;&gt;&gt;array([1, 2, 3]) pandas之读取外部数据12pd.read_csvpd.read_sql(sql_sentence, connection) pandas之DataFrame的创建12345678910111213141516# 方法一t = pd.DataFrame(np.arange(12).reshape(3,4),index=list(\"ABC\"),columns=list(\"WXYZ\"))# 方法二t_dict = &#123; \"name\":[\"zhangsan\", \"lisi\"], \"age\":[\"12\", \"20\"], &#125;pd.DataFrame(t_dict)# 方法三t_dict = [ &#123;\"name\": \"zhangsan\", \"age\": 12&#125;, &#123;\"name\": \"lisi\", \"age\": 20&#125;,]pd.DataFrame(t_dict) DataFrame的基础属性和整体情况查询12345678910111213# 基础属性df.shape # 行数 列数df.dtypes # 列数据类型df.ndim # 数据维度df.index # 行索引df.colums # 列索引df.values # 对象值，二维ndarray数组# 整体情况查询df.head(3) # 显示头部几行，默认5行de.tail(3) # 显示尾部几行，默认5行df.info() # 相关信息概览：行数，列数，列索引，列非空值个数，列类型，内存占用df.describe() # 快速综合统计结果：计数，均值，标准差，最大值，四分位数，最小值 对某一列进行排序12# 对Count_AnimalName列进行排序，ascending=False表示从大到小排序df.sort_values(by=\"Count_AnimalName\", ascending=False) DataFrame之取行或者列123456789df = pd.DataFrame(np.arange(56).reshape(7,8), index=list(\"ABCDEFG\"), columns=list(\"STUVWXYZ\"))# 取第X列df[\"X\"]# 取第X、Z列df[[\"X\", \"Z\"]]# 取第3到第6行df[2:6]# 取第3到第6行和第X列df[2:6][\"X\"] DataFrame之loc和iloc df.loc 通过标签索引行数据 Df.iloc 通过位置获取行数据 123456789101112131415# 取A行，W列交集的数据df.loc[\"A\", \"W\"]# 取A行和W、Z交集的数据df.loc[\"A\", [\"W\", \"Z\"]]# 取A、C行和W、Z交集的数据df.loc[[\"A\", \"c\"], [\"W\", \"Z\"]]# 取A行及A行之后所有行和W、Z的交集df.loc[\"A\": [\"W\", \"Z\"]]# 取A行到C行和W、Z的交集df.loc[\"A\":\"C\",[\"W\",\"Z\"]]# 取第2行到第3行和第3列、第4列的交集df.iloc[1:3, [2,3]]# 取第2行到第3行和第2列到第3列的交集df.iloc[1:3,1:3] 赋值更改数据的过程 12df.loc[\"A\", \"Y\"] = 100df.iloc[1:2,0:2] = 200 DataFrame之布尔索引1234567# 找到使用次数超过800的狗的名字df[df[\"Count_AnimalName\"]&gt;800]# 找到所有使用次数超过700并且名字的字符串的长度大于4的狗的名字df[(df[\"Row_Labels\"].str.len()&gt;4)&amp;(df[\"Count_AnimalName\"]&gt;700)]# &amp;符号表示：且# |符号表示：或 pandas之字符串方法 缺失数据的处理12345678910# 判断数据是否为NaNpd.isnull(df) # 是NaNpd.notnull(df) # 不是NaN# 处理方式1：删除NaN所在的行列t.dropna(axis=0,how='any',inplace=False)# 填充数据t.fillna(t.mean())t.fillna(t.median())t.fillna(0) 处理为0的数据：t[t==0]=np.nan 当然并不是每次为0的数据都需要处理 计算平均值等情况，nan是不参与计算的，但是0会 pandas常用统计方法12345678910111213# 评分的平均分rating_mean = df[\"Rating\"].mean()# 导演的人数temp_list = df[\"Actors\"].str.split(\",\").tolist()nums = set([i for j in temp_list for i in j])# 电影市场的最大最小值max_runtime = df[\"Runtime(Minutes)\"].max()max_runtime_index = df[\"Runtime(Minutes)\"].argmax()min_runtime = df[\"Runtime(Minutes)\"].min()min_runtime_index = df[\"Runtime(Minutes)\"].argmin()runtime_median = df[\"Runtime(Minutes)\"].median() 数据合并之join、mergejoin：默认情况下他是把行索引相同的数据合并到一起 merge:按照指定的列把数据按照一定的方式合并到一起 默认的合并方式inner：并集 outer：交集，NaN补全 left：左边为准，NaN补全 right：右边为准，NaN补全 分组和聚合1grouped = df.groupby(by=\"columns_name\") grouped是一个DataFrameGroupBy对象，是可迭代的。grouped中的每一个元素是一个元组元组里面是（索引(分组的值)，分组之后的DataFrame） 如果我们需要对国家和省份进行分组统计，应该怎么操作呢？ 1grouped = df.groupby(by=[df[\"Country\"],df[\"State/Province\"]]) 很多时候我们只希望对获取分组之后的某一部分数据，或者说我们只希望对某几列数据进行分组，这个时候我们应该怎么办呢？ 获取分组之后的某一部分数据： 1df.groupby(by=[\"Country\",\"State/Province\"])[\"Country\"].count() 对某几列数据进行分组： 1df[\"Country\"].groupby(by=[df[\"Country\"],df[\"State/Province\"]]).count() 观察结果，由于只选择了一列数据，所以结果是一个Series类型，如果我想返回一个DataFrame类型呢？ 12t1 = df[[\"Country\"]].groupby(by=[df[\"Country\"],df[\"State/Province\"]]).count()t2 = df.groupby(by=[\"Country\",\"State/Province\"])[[\"Country\"]].count() 以上的两条命令结果一样和之前的结果的区别在于当前返回的是一个DataFrame类型 索引和复合索引简单的索引操作： 获取index：df.index 指定index ：df.index = [‘x’,’y’] 重新设置index : df.reindex(list(“abcedf”)) 指定某一列作为index ：df.set_index(“Country”,drop=False) 返回index的唯一值：df.set_index(“Country”).index.unique() 12345678910111213141516171819202122232425262728a = pd.DataFrame(&#123;'a': range(7),'b': range(7, 0, -1),'c': ['one','one','one','two','two','two', 'two'],'d': list(\"hjklmno\")&#125;)a&gt;&gt;&gt; a b c d0 0 7 one h1 1 6 one j2 2 5 one k3 3 4 two l4 4 3 two m5 5 2 two n6 6 1 two ox = a.set_index([\"c\",\"d\"])[\"a\"]x&gt;&gt;&gt;c done h 0 j 1 k 2two l 3 m 4 n 5 o 6Name: a, dtype: int64 x[\"one\", \"h\"]&gt;&gt;&gt;0 x.swaplevel() 复合索引中交换索引 123456789101112x = x.swaplevel() x&gt;&gt;&gt;d c h one 0j one 1k one 2l two 3m two 4n two 5o two 6Name: a, dtype: int64 pandas中的时间序列时间序列的生成1pd.date_range(start=None, end=None, periods=None, freq='D') start和end以及freq配合能够生成start和end范围内以频率freq的一组时间索引start和periods以及freq配合能够生成从start开始的频率为freq的periods个时间索引 关于频率的更多缩写 在DataFrame中使用时间序列12index=pd.date_range(\"20170101\",periods=10)df = pd.DataFrame(np.random.rand(10),index=index) 可以使用pandas提供的方法把时间字符串转化为时间序列 1df[\"timeStamp\"] = pd.to_datetime(df[\"timeStamp\"],format=\"\")format参数大部分情况下可以不用写，但是对于pandas无法格式化的时间字符串，我们可以使用该参数，比如包含中文 pandas重采样重采样：指的是将时间序列从一个频率转化为另一个频率进行处理的过程，将高频率数据转化为低频率数据为降采样，低频率转化为高频率为升采样。 pandas提供了一个resample的方法来帮助我们实现频率转化 Periodlndex之前所学习的DatetimeIndex可以理解为时间戳那么现在我们要学习的PeriodIndex可以理解为时间段 1periods = pd.PeriodIndex(year=data[\"year\"],month=data[\"month\"],day=data[\"day\"],hour=data[\"hour\"],freq=\"H\")","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"http://yoursite.com/tags/numpy/"},{"name":"pandas","slug":"pandas","permalink":"http://yoursite.com/tags/pandas/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]}]}